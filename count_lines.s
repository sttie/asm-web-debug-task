/*
    Идея решения:
    Нужно найти линии в столбцах => нужно проходиться по столбцам, а не строкам.
    При этом аждая строка задается своим указателем на первый элемент этой строки.
    Так что можно запустить цикл по количеству столбцов, а в нем - цикл
    по количеству строк. После обработки текущего элемента строки указатель
    на текущий элемент строки передвигается на следующий, так что можно работать
    с каждым элементом строки как с первым.
    Также не забываем о том, чтобы восстановить начальное состояние всех указателей.
    Портить аргументы по указателю - плохо!
*/

.intel_syntax noprefix
.global count_lines


.text
count_lines:
    /* Аргументы:
        rdi = указатель на строку двумерного массива,
        rsi = кол-во строк,
        rdx = кол-во столбцов
    */

    // сохраняем аргументы
    mov data_start_ptr, rdi
    mov rows, rsi
    mov cols, rdx

    /* т.к. указатели на массивы-строки будут изменяться, 
        нужно их сохранить, а в конце восстановить */
    jmp save_start_state

start_main_loop:
    // инициализируем счетчик по столбцам
    mov rcx, cols

    cols_loop:
        // в начале каждой итерации максимальная длина = 0
        xor rax, rax

        // сохраняем значение счетчика по столбцам на стеке
        push rcx
        // и заменяем его на счетчик по строкам
        mov rcx, rows
        // возвращаемся к первой строке
        mov rdi, data_start_ptr

        rows_loop:
            // в rbx теперь - указатель на строку
            mov rbx, [rdi]
            // в dl теперь - непосредственно значение матрицы (помним, что это 1 байт!)
            mov dl, byte ptr [rbx]

            /* если текущее значение равно 0, то увеличиваем rax
               иначе обновляем ответ и обнуляем rax */
            cmp dl, 0
            jne dl_is_not_0

            inc rax
            call update_max
            jmp rows_end_loop

        dl_is_not_0:
            mov rax, 0

        rows_end_loop:
            // передвигаем указатель на текущее значение на следующее значение
            add rbx, 1
            mov [rdi], rbx
            // и переходим к следующей строке (указатели имеют размер 8 байт)
            add rdi, 8

            loop rows_loop


        // восстанавливаем значение счетчика по столбцам
        pop rcx
        loop cols_loop
    
    // перед завершением работы необходимо восстановить все указатели
    jmp load_start_state

exit:
    /* Возвращаемое значение передается через регистр rax 
       => заносим в rax значение из answer */
    mov rax, answer
    ret


/*
    Процедура обновляет значение в answer в случае, если answer < rax 
*/
update_max:
    cmp rax, answer
    jle update_max_return
    mov answer, rax

update_max_return:
    ret


/*
    Сохраняем на стеке указатели на строки в двумерном массиве,
    а также указатель на конец массива строк
*/
save_start_state:
    mov rcx, rows

    push_loop:
        push [rdi]
        add rdi, 8

        loop push_loop

    // сохраняем указатель на конец массива указателей на строки
    push rdi
    jmp start_main_loop


load_start_state:
    // на вершине стека - указатель на конец (невключительный) массива строк
    pop rdi
    mov rcx, rows

    pop_loop:
        sub rdi, 8
        pop [rdi]

        loop pop_loop

    jmp exit


.data
data_start_ptr: .quad 0
rows: .quad 0
cols: .quad 0
answer: .quad 0
